function histData = getBoundary(coords,img,extent,object)

% getBoundary.m
% This function takes the coordinates of the boundary endpoints as inputs, scales them appropriately, and constructs the boundary line segments. 
% A line is then extended in both directions from the center of each curvelet and the angle of intersection with the boundary is found. 
% 
% Inputs:
% 
% coords - the locations of the endpoints of each line segment making up the boundary
% 
% img - the image being measured
% 
% extent - the location of the lower left corner, width and height of the image in the figure window, in scaled units
% 
% object - a struct containing the center and angle of each measured curvelet, generated by the newCurv function
% 
% Output:
% 
% histData = the bins and counts of the angle histogram
% 
% Carolyn Pehlke, Laboratory for Optical and Computational Instrumentation, August 2010

bottom = extent(2) + extent(4);
left = extent(1);
top = extent(2);
right = extent(1) + extent(3);
width = extent(3);
height = extent(4);
intersection = 0;

% scaling the endpoints back into image units
rows = round((bottom - coords(:,2)) * size(img,2)/height);
cols = round((coords(:,1) - left) * size(img,1)/width);

% structs that will hold the boundary line segments and the lines from the
% curvelets
lineSegs(1:length(coords)-1) = struct('slope',[],'intercept',[],'pointVals',[],'angle',[],'intAngles',[],'intLines',[],'intDist',[]);
curvLines(1:length(object)) = struct('center',[],'angle',[],'slope',[],'intercept',[],'pointVals',[]);

% finding every point in the boundary line segments and calculating the
% angle of the segment
for aa = 2:length(coords)
    
    lineSegs(aa-1).slope = (rows(aa) - rows(aa-1))/(cols(aa) - cols(aa-1));
    lineSegs(aa-1).intercept = rows(aa) - (cols(aa)*lineSegs(aa-1).slope);
    if isinf(lineSegs(aa-1).slope)
        lineSegs(aa-1).angle = 90;
    else
        lineSegs(aa-1).angle = atand(-lineSegs(aa-1).slope);
    end
    if lineSegs(aa-1).angle < 0
        lineSegs(aa-1).angle = lineSegs(aa-1).angle + 180;
    end
    if cols(aa-1) <= cols(aa)
        colVals = cols(aa-1):1:cols(aa);
    else
        colVals = cols(aa-1):-1:cols(aa);
    end
    rowVals = round(lineSegs(aa-1).slope * colVals + lineSegs(aa-1).intercept);
    lineSegs(aa-1).pointVals = horzcat(rowVals',colVals');
end

% finding each point of the line passing through the centerpoint of the
% curvelet with slope of tan(curvelet angle)
for bb = 1:length(object)
    curvLines(bb).center = object(bb).center;
    curvLines(bb).angle = object(bb).angle;
    curvLines(bb).slope = -tand(object(bb).angle);
    curvLines(bb).intercept = object(bb).center(1) - (curvLines(bb).slope)*object(bb).center(2);
    colVals = 1:size(img,2);
    rowVals = round((curvLines(bb).slope)*colVals + curvLines(bb).intercept);
    curvLines(bb).pointVals = horzcat(rowVals',colVals');
    
%     plot(colVals,rowVals)
end

% finding the angles and points of intersection between the curvelet lines and the
% boundary line segments
for cc = 1:length(lineSegs)
    for dd = 1:length(curvLines)
        intersection = intersect(lineSegs(cc).pointVals,curvLines(dd).pointVals,'rows');
        
        if intersection
            tempAng(dd) = max(lineSegs(cc).angle,curvLines(dd).angle) - min(lineSegs(cc).angle,curvLines(dd).angle);
            tempLines(dd) = dd;
            tempDist(dd) = min(sqrt((curvLines(dd).center(1) - lineSegs(cc).pointVals(:,1)).^2 + (curvLines(dd).center(2) - lineSegs(cc).pointVals(:,2)).^2));
        else
            tempAng(dd) = -1000;
            tempLines(dd) = -1000;
            tempDist(dd) = -1000;
        end
        
    end
    
    idx = tempAng > -1000;
    tempAng = tempAng(idx);
    
    idx = tempAng > 180;
    tempAng(idx) = tempAng(idx) - 180;
    
    idx = tempAng > 90;
    tempAng(idx) = 180 - tempAng(idx);
    lineSegs(cc).intAngles = tempAng;
    
    idx = tempLines > -1000;
    lineSegs(cc).intLines = tempLines(idx);
    
    idx = tempDist > -1000;
    lineSegs(cc).intDist = tempDist(idx);
        
end

for ee = 1:length(lineSegs)-1
    for ff = (ee+1):length(lineSegs)-1
        [intTest iEE iFF] = intersect(lineSegs(ee).intLines,lineSegs(ff).intLines);
        if intTest
            idxE = lineSegs(ee).intDist(iEE) >= lineSegs(ff).intDist(iFF);
            idxF = lineSegs(ff).intDist(iFF) > lineSegs(ee).intDist(iEE);
            lineSegs(ee).intDist(idxE) = [];
            lineSegs(ee).intLines(idxE) = [];
            lineSegs(ee).intAngles(idxE) = [];
            lineSegs(ff).intDist(idxF) = [];
            lineSegs(ff).intLines(idxF) = [];
            lineSegs(ff).intAngles(idxF) = [];
        end
    end
end

% output
measAngs = horzcat(lineSegs.intAngles);
bins = 0:5:90;
[n xout] = hist(measAngs,bins);
histData = vertcat(n,xout);
histFig = figure('Units','normalized','Name','Histogram'); 
defaultBackground = get(0,'defaultUicontrolBackgroundColor');
set(histFig,'Color',defaultBackground)
histAx = axes('Parent',histFig,'Units','normalized','FontName','FixedWidth','OuterPosition',[0 .175 1 .825]);
bar(histAx,xout,n)
title(histAx,'Angles With Respect to Boundary')

outMean = uicontrol(histFig,'Style','text','String',['Mean angle with respect to boundary: ',num2str(mean(measAngs),'%6.2f')],'Units','normalized','Position',[.1,.1 .8 .1]);
outStd = uicontrol(histFig,'Style','text','String',['Standard deviation of angles with respect to boundary: ',num2str(std(measAngs),'%6.2f')],'Units','normalized','Position',[.1,.05 .9 .1]);
            
set([outMean outStd],'FontName','FixedWidth')
set([outMean outStd],'HorizontalAlignment','left')
     
